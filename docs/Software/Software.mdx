---
title: "Software Engineering"
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

```mermaid
SoftwareEngineering
│
├── Software Architecture
│   ├── Project Architecture
│   │   ├── Monolith vs Microservices
│   │   ├── Layered Architecture (Presentation / Business / Data)
│   │   ├── Clean Architecture / Hexagonal Architecture
│   │   └── Design Patterns (Factory, Singleton, Observer, Strategy)
│   ├── OS Architecture
│   │   ├── Kernel / User Space / Hardware
│   │   └── Processes / Memory / File System / Network
│
├── Communication
│   └── API Design
│    ├── REST
│    ├── GraphQL
│    └── gRPC / RPC
|
├── Development Practices
│   ├── Version Control (Git)
│   ├── CI/CD Pipelines
│   ├── Test-Driven Development (TDD)
│   ├── Code Review & Static Analysis
│   └── Documentation Practices
│
├── Containerization & Orchestration
│   ├── Docker
│   ├── Kubernetes
│   ├── Docker Compose
│   └── Helm / Charts
│
├── Dependency & Package Management
│   ├── npm / yarn / pip / Maven / Gradle
│   └── Dependency Graph & Versioning
│
├── Security & Quality
│   ├── Secure Coding Principles
│   ├── Input Validation & Authentication
│   ├── Testing (Unit, Integration, E2E)
│   └── Monitoring & Logging
│
├── Performance & Scalability (Core SWE)
│   ├── Profiling / Bottleneck Analysis
│   ├── Load Balancing
│   └── Horizontal vs Vertical Scaling
│
└── DevOps & Infrastructure
    ├── Infrastructure as Code (Terraform, Ansible)
    ├── Cloud Providers (AWS / GCP / Azure)
    ├── Deployment Strategies (Blue/Green, Canary)
    └── Monitoring / Observability Tools
```


---

## Principles

<Tabs>
<TabItem value="solid" label="SOLID">

**Single Responsibility Principle (SRP)**  
A class should have only one reason to change. Each class should handle a single responsibility.

**Open/Closed Principle (OCP)**  
Software entities should be open for extension but closed for modification.

**Liskov Substitution Principle (LSP)**  
Subtypes must be substitutable for their base types. Child classes should honor the contract of their parent classes.

**Interface Segregation Principle (ISP)**  
Interfaces should be small and specific. Clients should not be forced to depend on methods they do not use.

**Dependency Inversion Principle (DIP)**  
Depend on abstractions, not concrete implementations.

</TabItem>
<TabItem value="dry" label="DRY">

**Don't Repeat Yourself (DRY)**  
Avoid duplicating code; abstract repeated logic into reusable functions or modules.

</TabItem>
<TabItem value="kiss" label="KISS">

**Keep It Simple, Stupid (KISS)**  
Design systems in the simplest way possible; avoid unnecessary complexity.

</TabItem>
<TabItem value="4-pillars" label="4 pillars of OOP">

These are fundamental principles that form the foundation of OOP and guide how to design and structure software systems.

## 1. Inheritance
Child/Sub Class EXTENDS Parent/Super Class. Reuse methods while following the hierarchy.

## 2. Encapsulation
Group data and behavior into logical components; hide implementation using private attributes + getters/setters.

## 3. Abstraction
Expose only essential attributes; hide unnecessary details. Use abstract classes and interfaces.

## 4. Polymorphism
Methods can have multiple forms; allows runtime flexibility. Child classes override parent methods.

</TabItem>
<TabItem value="eq-4-pillars" label="4 pillars in FP">

## 1. Function Composition
Combine simple, reusable functions into larger functionality.

## 2. Immutability
Encapsulate data in immutable form to prevent accidental modification.

## 3. Pure Functions
Consistent results, no side effects. Enhances testability and predictability.

## 4. Higher-Order Functions
Functions as first-class citizens; can accept or return other functions.

**Additional FP Concepts**
- Lazy evaluation
- Referential transparency

</TabItem>
</Tabs>
