---
title: "Principles"
sidebar_position: 3
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::tip Concept Overview
Engineering Principles are foundational guidelines that shape how software and data systems are designed, evolved, and operated.

Some principles are cross-cutting (apply everywhere), while others are domain-specific.  
A Technical Analyst must understand *both the principle and the context in which it applies*.
:::

---

## Why Principles Matter for a Technical Analyst

Principles help TAs:

- Evaluate designs without relying on specific tools
- Understand *why* trade-offs were made
- Ask better questions during reviews and incidents
- Avoid applying ‚Äúbest practices‚Äù blindly across domains

> Principles guide decisions ‚Äî they are not absolute rules.

---

## Cross-Cutting Engineering Principles

These principles apply across Software Engineering, Data Engineering, and Platform work, but manifest differently depending on context.

<Tabs>
<TabItem value="dry" label="DRY">

### Don‚Äôt Repeat Yourself (DRY)
A system should have a single source of truth for *logic, rules, or knowledge*.

**In Software Engineering**
- Strongly enforced
- Reduces bugs and inconsistent behaviour
- Duplication usually indicates poor abstraction

Good DRY target: business logic, algorithms, rules

### In Data Engineering
- Applied selectively
- Logic should be DRY, data often should not be
- Duplication may be intentional for:
  - Performance
  - Historical accuracy
  - Auditability
  - Isolation

TA rule of thumb:  
üëâ *DRY the logic, duplicate the facts when needed.*

</TabItem>

<TabItem value="kiss" label="KISS">

### Keep It Simple, Stupid (KISS)
Prefer the simplest solution that meets the requirements.

**SWE perspective**
- Avoid unnecessary abstractions
- Reduce cognitive load
- Improve maintainability

**Data perspective**
- Prefer understandable pipelines over clever ones
- Make transformations explicit
- Optimise only when scale or cost demands it

TA signal:  
Complexity added ‚Äújust in case‚Äù rather than to solve a real problem.

</TabItem>
<TabItem value="separation" label="Separation of Concerns">

Different responsibilities should be isolated.

- Logic vs data
- Ingestion vs transformation
- Control plane vs data plane

Why it matters:
- Enables independent evolution
- Improves ownership clarity
- Reduces blast radius

</TabItem>
</Tabs>

---

## Software Engineering Principles

<Tabs>
<TabItem value="solid" label="SOLID">

The SOLID principles focus on building software that is resilient to change.

### Single Responsibility Principle (SRP)
A component should have one reason to change.

### Open/Closed Principle (OCP)
Open for extension, closed for modification.

### Liskov Substitution Principle (LSP)
Subtypes must honour base type contracts.

### Interface Segregation Principle (ISP)
Small, focused interfaces are better than large ones.

### Dependency Inversion Principle (DIP)
Depend on abstractions, not implementations.

TA signal:  
SOLID violations often show up as brittle systems or painful change.

</TabItem>

<TabItem value="oop" label="4 Pillars of OOP">

### Inheritance
Reuse behaviour via parent‚Äìchild relationships.

### Encapsulation
Hide internal state; expose controlled interfaces.

### Abstraction
Expose essentials, hide details.

### Polymorphism
Treat different implementations uniformly.

TA caution:  
Inheritance increases coupling ‚Äî composition is often safer.

</TabItem>

<TabItem value="fp" label="Functional Programming Principles">

### Function Composition
Build behaviour from small, reusable functions.

### Immutability
Avoid shared mutable state.

### Pure Functions
Predictable behaviour, easy testing.

### Higher-Order Functions
Functions as first-class values.

TA signal:  
Common in data processing, concurrency-heavy systems, and pipelines.

</TabItem>
</Tabs>

## Data Engineering Principles

<Tabs>
<TabItem value="acid" label="ACID">

Principles for transactional consistency.

### Atomicity
A transaction is treated as a single, indivisible unit: it either completes fully or has no effect at all.

### Consistency
Every transaction moves the database from one valid state to another, enforcing all rules, constraints, and invariants.

### Isolation
Concurrent transactions behave as if they were executed sequentially, preventing interference or partial visibility of intermediate states.

### Durability
Once a transaction is committed, its results persist even in the event of crashes, power loss, or system failures.

**Typical use:** OLTP systems, financial workflows
**Trade-off:** Scalability and latency

</TabItem>

<TabItem value="base" label="BASE">

Principles for large-scale distributed systems.

### Basically Available
The system guarantees availability even under partial failures, though responses may be degraded or stale.

### Soft State
The system‚Äôs state may change over time without new input because of asynchronous replication or background processes.

### Eventually Consistent
Given enough time without new updates, all replicas converge to the same state.

**Typical use:** Distributed data stores
**Trade-off:** Immediate consistency

</TabItem>

<TabItem value="idempotency" label="Idempotency">

### Retries
An operation can be executed multiple times with the same effect as executing it once, ensuring safe retries in unreliable or distributed environments.

- Critical for distributed pipelines
- Supports at-least-once delivery
- Reduces failure impact

</TabItem>
 <TabItem value="schema" label="Schema Management">

### Read & Write

- **Schema-on-write** ‚Üí Data must conform before being stored; ensures quality, consistency, and strong governance.
- **Schema-on-read** ‚Üí Structure is applied when data is consumed; maximises flexibility and supports diverse use cases.

**TA focus:**
Governance vs agility trade-offs.

</TabItem>

<TabItem value="lineage" label="Lineage & Immutability">

### Traceability

- Data should be traceable end-to-end across ingestion, transformation, and consumption.
- Raw data should remain immutable to preserve auditability and reproducibility.
- Transformations should be deterministic and well-documented.

**TA signal:**
Essential for debugging, compliance, and trust.

</TabItem>

</Tabs>

