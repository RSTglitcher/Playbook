---
title: "Requirements"
sidebar_position: 8
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::tip Concept Overview
Requirements are not just statements of need â€” they are **alignment tools**, **boundaryâ€‘setting tools**, and **decisionâ€‘making tools**.

For a Technical Analyst, requirements are how you:
- Make implicit assumptions explicit
- Anchor conversations in facts
- Create shared accountability
- Reduce ambiguity and future conflict
:::

---

# ðŸ§­ The TA Mental Model for Requirements

A requirement is **not** a wish list item.
It is a **constraint**, **condition**, or **decision rule** that must be met for a solution to be viable.

**Backbone of the TA Role: Context â†’ Problem â†’ Constraints â†’ Requirements â†’ Acceptance â†’ Decision**

---

## ðŸ§© What Good Requirements Look Like

A good requirement is:

- [x] **Clear** â€” no ambiguity
- [x] *Testable** â€” you can verify if itâ€™s met
- [x] **Bounded** â€” it has a scope
- [x] **Neutral** â€” no blame, no emotion
- [x] **Contextualised** â€” tied to a real constraint
- [x] **Negotiable or Nonâ€‘Negotiable** â€” explicitly stated
- [x] **Traceable** â€” linked to a problem or risk

---

##  ðŸ§± The TA Requirement Pattern

Every requirement you write should follow this structure:

1. **Context**
> - Why this requirement exists.

2. **Constraint**
> - What limits the solution space.

3. **Requirement Statement**
> - A single sentence, structured as:

```
The solution must <do/enable/support> <behaviour or condition> because <reason>.
```

4. **Acceptance Criteria**
> - How we know the requirement is met.

5. **Negotiability**
> - **Nonâ€‘negotiable** (fixed constraint)
> - **Negotiable** (preference)
> - **Teamâ€‘specific** (must be supported via extension points)

---

# ðŸ§© Example Requirements (Sideâ€‘byâ€‘Side)

<Tabs>

<TabItem value="good" label="Good Requirement">

```
Context:
The team deploys Python services to Kubernetes using a shared base image.

Constraint:
The base image is maintained by the platform team and cannot be modified.

Requirement:
The cookiecutter template must support using the shared Python base image because teams cannot maintain custom images.

Acceptance Criteria:
- Dockerfile references the shared base image
- No custom OS-level dependencies required
- Build pipeline succeeds using the shared image

Negotiability:
Nonâ€‘negotiable
```

</TabItem>

<TabItem value="bad" label="Bad Requirement">

```
We should use the platform image because thatâ€™s what everyone else does.
```

</TabItem>

</Tabs>

---

## ðŸ§© Requirements Presentation Structure

1. **Executive Summary**
- What you analysed
- What you found
- What decisions are needed

2. **Project Context**
- Team
- Tech stack
- Constraints
- Deployment model

3. **Fixed vs Flexible vs Teamâ€‘Specific**
A table like this:

| Category | Items | Notes |
|---------|-------|-------|
| Fixed | Python 3.12, shared base image | Cannot change |
| Flexible | Test framework | Can change with effort |
| Teamâ€‘specific | ETL folder structure | Must be supported |

4. **Requirements List**
Each requirement in the TA pattern format.

5. **Adoption Conditions**
What must be true for the team to adopt the template.

6. **Risks & Dependencies**
What could block adoption.

7. **Next Steps**
Clear, shared actions â€” not all assigned to you.

---

## ðŸ›¡ï¸ BAU

1. Operate from written requirements
> - Never rely on verbal agreements.

2. Use the TA requirement pattern to create clarity
> - It reduces political manoeuvring.

3. Document alignment decisions
> - This protects you from blame shifting.

4. Set boundaries early
> - â€œThis is what we agreed. This is what Iâ€™m delivering.â€

5. Avoid taking on unbounded work
> - If itâ€™s not in the requirements, itâ€™s not your responsibility.

6. Protect your energy
> _ Ensure you have stability to operate as you need

