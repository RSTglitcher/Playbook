---
title: "Data Structures & Algorithms"
sidebar_position: 5
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

:::tip Concept Overview
**Data Structures and Algorithms** describe how data is organised, accessed, and transformed.

For a Technical Analyst, they explain:
- Why systems behave the way they do  
- Where performance bottlenecks come from  
- How to reason about scalability without reading code  
:::

---

# Why This Matters for a Technical Analyst

A TA uses data‑structure knowledge to:

- Predict performance issues before they appear  
- Spot inefficient access patterns in designs  
- Understand Big‑O discussions at a behavioural level  
- Ask sharper questions during reviews and incidents  

You don’t need implementation detail — you need **intuition, trade‑offs, and system impact**.

---

# Pattern Recognition for Data Structures

A TA should recognise **problem shapes** and map them to the right structure:

| Problem Shape | Likely Structure |
|---------------|------------------|
| Need fast lookup by key | Map / Dictionary |
| Need uniqueness | Set |
| Need ordering | List / Array |
| Need FIFO | Queue |
| Need LIFO | Stack |
| Need hierarchical relationships | Tree |
| Need network/relationship modelling | Graph |
| Need sorted data with fast inserts | Balanced tree / Heap |

---

<Tabs>

<TabItem value="structures" label="Data Structures">

# Core Mental Models

## 1. Primitive vs Reference Types

### Diagram
```
Primitive:  [ 42 ]
Reference:  [ ptr ] --> [ Object in Heap ]
```

| Category | Behaviour | TA Insight |
|---------|-----------|------------|
| **Primitive** | Stored directly, fixed size | Predictable memory, fast operations |
| **Reference** | Pointer to heap object | Flexibility but GC/heap overhead |

**TA takeaway:**  
Reference-heavy designs increase GC pressure and memory churn.

---

# 2. Collections (Behavioural View)

## Arrays / Lists

### Diagram
```
Index → 0  1  2  3
        [A][B][C][D]
```

**Strengths:**  
- Fast indexed access  
- Good for sequential scans  

**Weaknesses:**  
- Inserts/deletes are expensive  
- Resizing can be costly  

**Use When:**  
- Order matters  
- Data size is predictable  

---

## Sets

### Diagram
```
{ A, B, C }   // No duplicates
```

**Strengths:**  
- Fast membership checks  
- Enforces uniqueness  

**Weaknesses:**  
- No ordering  
- Hashing overhead  

**Use When:**  
- Deduplication  
- Fast “contains?” checks  

---

## Maps / Dictionaries

### Diagram
```
Key → Value
A   → 1
B   → 2
```

**Strengths:**  
- O(1) average lookup  
- Natural modelling for keyed data  

**Weaknesses:**  
- Hash collisions degrade performance  
- Memory overhead  

**Use When:**  
- Fast lookup by identifier  
- Caching, indexing, metadata  

---

## Queues (FIFO)

### Diagram
```
Front → [A][B][C] → Back
```

**Use When:**  
- Task scheduling  
- Message processing  
- Pipelines  

---

## Stacks (LIFO)

### Diagram
```
Top → [C]
       [B]
       [A]
```

**Use When:**  
- Undo operations  
- Expression evaluation  
- Depth-first traversal  

---

# 3. Trees & Graphs (TA-Level Intuition)

## Trees

### Diagram
```
      A
     / \
    B   C
```

**Use When:**  
- Hierarchical data  
- Indexing (B‑trees)  
- Searching (binary search trees)  

**TA signal:**  
Tree depth affects lookup time.

---

## Graphs

### Diagram
```
A — B — C
 \     /
   D
```

**Use When:**  
- Networks  
- Dependencies  
- Relationships  

**TA signal:**  
Cycles and connectivity affect traversal cost.

---

# 4. Big‑O Intuition (TA Edition)

You don’t need formulas — you need **shapes**.

| Operation | Array/List | Set | Map |
|-----------|------------|-----|-----|
| Lookup | O(n) | O(1) | O(1) |
| Insert | O(n) | O(1) | O(1) |
| Delete | O(n) | O(1) | O(1) |

**TA takeaway:**  
Repeated linear scans (O(n)) are the root cause of many performance issues.

</TabItem>

<TabItem value="algorithms" label="Algorithms">

# Algorithm Mental Models

## What an Algorithm Really Is
A **procedure** for transforming input → output with predictable cost.

For a TA, algorithms matter because they define:
- Time complexity  
- Space usage  
- Behaviour under load  

---

# Core Algorithm Categories

## Searching

### Diagram
```
Linear: A → B → C → D
Binary:     [mid]
```

**TA signal:**  
Binary search requires sorted data.

---

## Sorting

### Diagram
```
Unsorted → [C, A, D, B]
Sorted   → [A, B, C, D]
```

**TA signal:**  
Sorting cost dominates many pipelines.

---

## Traversal (Trees/Graphs)

### Diagram
```
DFS: Deep first
BFS: Level by level
```

**TA signal:**  
DFS uses stack; BFS uses queue → memory behaviour differs.

---

## Aggregation

Examples: sum, count, group-by.

**TA signal:**  
Aggregation cost grows with dataset size; grouping can explode memory.

---

## Filtering

**TA signal:**  
Filtering early reduces downstream cost (“pushdown predicates”).

---

# Algorithmic Trade-offs

- Speed vs memory  
- Precomputation vs runtime cost  
- Accuracy vs approximation  
- Simplicity vs optimisation  

**TA takeaway:**  
Algorithms optimised for small datasets often collapse at scale.

</TabItem>

<TabItem value="logic" label="Conditionals & Logic">

# Conditionals & Branching

## Why It Matters
- Branching affects CPU prediction  
- Deep conditional trees reduce readability  
- Complex logic often hides bugs  

### Diagram
```
if → else → else if → else
```

**TA signal:**  
Complex conditionals often indicate missing abstractions or unclear domain rules.

---

## Common Operators

```shell
| Operator | Meaning |
|--------|---------|
| >  | Greater than |
| >= | Greater or equal |
| <  | Less than |
| <= | Less or equal |
| == | Equal |
| != | Not equal |
| AND | All conditions true |
| OR | Any condition true |
| NOT | Negates condition |
```

</TabItem>

<TabItem value="uml" label="UML & Structure">

# UML for TAs (Structural Reasoning)

## Visibility & Relationships

| Symbol | Meaning | Purpose |
|--------|---------|---------|
| + | Public | Exposed to all |
| # | Protected | Subclasses only |
| - | Private | Internal |
| Interface | Dotted line | Contract |
| Abstract | Italic | Cannot instantiate |
| Aggregation | White diamond | Loose ownership |
| Composition | Black diamond | Strong ownership |
| Static | Underlined | Class-level |

---

## Why UML Still Matters

UML helps a TA:

- Understand ownership  
- See coupling and dependencies  
- Communicate structure quickly  
- Clarify intent without code  

**TA takeaway:**  
UML is a thinking tool, not a documentation burden.

</TabItem>

</Tabs>

