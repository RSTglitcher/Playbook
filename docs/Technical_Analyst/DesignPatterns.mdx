---
title: "Design Patterns"
sidebar_position: 3
---

A fast, decisionâ€‘oriented reference for recognising and applying common design patterns.  
Each pattern includes: **intent â†’ when to use â†’ diagram â†’ trade-offs â†’ TA lens â†’ examples**.

---

## ðŸ§­ Pattern Decision Map

| Problem Shape | Consider These Patterns |
|---------------|-------------------------|
| Need to swap behaviour | Strategy, State |
| Need to notify many listeners | Observer, Pub/Sub |
| Need to simplify a complex API | Facade |
| Need to adapt incompatible interfaces | Adapter |
| Need to build complex objects | Builder |
| Need a single shared instance | Singleton |
| Need to control object creation | Factory Method |
| Need to add behaviour dynamically | Decorator |

---

# Creational Patterns

---

## Singleton

**Intent:** Ensure only one instance exists and provide global access.

**Use When:**  
- You need a single source of truth  
- Object creation is expensive  
- Global coordination is required  

```mermaid
+------------------+
|   Singleton      |
|------------------|
|  getInstance()   |
+------------------+
        |
        v
   [Single Object]
```

**Trade-offs:**  
- âœ” Simple global access  
- âœ” Prevents duplicate state  
- âœ˜ Harder to test  
- âœ˜ Hidden dependencies  

**TA Lens:**  
Useful when evaluating centralised components (config managers, connection pools).

**Examples:**  
- Database connection manager  
- Global configuration registry  

---

## Factory Method

**Intent:** Delegate object creation to subclasses.

**Use When:**  
- Object creation varies by context  
- You want consistent construction logic  
- You want to avoid scattered `new` calls  

```mermaid
Creator
+----------------------+
| factoryMethod()      |
+----------------------+
          |
          v
   Product (interface)
      ^          ^
      |          |
 ProductA    ProductB
```

**Trade-offs:**  
- âœ” Centralised creation logic  
- âœ” Supports extensibility  
- âœ˜ More indirection  
- âœ˜ Can be overused  

**TA Lens:**  
Useful for plugin systems, connectors, and integration points.

**Examples:**  
- Cloud provider SDKs  
- Storage client factories  

---

## Builder

**Intent:** Construct complex objects step-by-step.

**Use When:**  
- Objects have many optional parameters  
- Construction logic is complex  
- You want readable, fluent creation  

```mermaid
Director ----> Builder Interface
                  |
        ---------------------
        |         |         |
   BuilderA   BuilderB   BuilderC
```

**Trade-offs:**  
- âœ” Clear construction  
- âœ” Avoids telescoping constructors  
- âœ˜ More classes  
- âœ˜ Can be verbose  

**TA Lens:**  
Useful when evaluating APIs that assemble complex configurations (pipelines, queries).

**Examples:**  
- SQL query builders  
- Cloud resource configuration builders  

---

# Structural Patterns

---

## Adapter

**Intent:** Convert one interface into another expected by the client.

**Use When:**  
- Two systems donâ€™t naturally fit together  
- You want to reuse existing components  
- You need compatibility without rewriting  

```mermaid
Client ---> Adapter ---> Adaptee
```

**Trade-offs:**  
- âœ” Enables reuse  
- âœ” Decouples systems  
- âœ˜ Adds indirection  
- âœ˜ Can hide complexity  

**TA Lens:**  
Useful when integrating legacy systems or mismatched APIs.

**Examples:**  
- Wrapping a REST API to look like a repository  
- Converting event formats  

---

## Facade

**Intent:** Provide a simplified interface to a complex subsystem.

**Use When:**  
- A system has many moving parts  
- You want to hide complexity  
- You want a clean entry point  

```mermaid
        +---------+
Client ->| Facade |----> Subsystem A
        +---------+----> Subsystem B
                     \-> Subsystem C
```

**Trade-offs:**  
- âœ” Simplifies usage  
- âœ” Reduces coupling  
- âœ˜ Can become a god-object  
- âœ˜ May hide important details  

**TA Lens:**  
Useful when assessing SDKs, orchestration layers, or platform abstractions.

**Examples:**  
- Cloud service wrappers  
- Data platform orchestration APIs  

---

## Decorator

**Intent:** Add behaviour dynamically without modifying the original object.

**Use When:**  
- You want flexible, runtime composition  
- You want to avoid subclass explosion  
- You need optional behaviours  

```mermaid
Client
   |
   v
+-----------+
| Decorator |----> Component
+-----------+
       |
       v
  [Wrapped Component]
```

**Trade-offs:**  
- âœ” Flexible composition  
- âœ” Avoids deep inheritance  
- âœ˜ Can be hard to trace  
- âœ˜ Many small objects  

**TA Lens:**  
Useful when evaluating middleware, pipelines, or request/response wrappers.

**Examples:**  
- HTTP middleware  
- Logging wrappers  

---

# Behavioral Patterns

---

## Strategy

**Intent:** Swap algorithms or behaviours at runtime.

**Use When:**  
- You want interchangeable behaviours  
- Logic varies by context  
- You want to avoid giant `if/else` blocks  

```mermaid
+-----------+        +----------------+
|  Context  |------->|  Strategy      |
| set(strat)|        |  interface     |
+-----------+        +----------------+
        |                   ^
        |                   |
        v                   |
   +-----------+     +-------------+
   | StrategyA |     | StrategyB   |
   +-----------+     +-------------+
```

**Trade-offs:**  
- âœ” Cleaner extensibility  
- âœ” Behaviour is isolated  
- âœ˜ More classes  
- âœ˜ Requires clear interfaces  

**TA Lens:**  
Useful for pluggable components (pricing engines, routing logic).

**Examples:**  
- Retry strategies  
- Sorting algorithms  

---

## Observer

**Intent:** Notify multiple subscribers when something changes.

**Use When:**  
- Many components depend on one source  
- You need event-driven behaviour  
- Loose coupling is important  

```mermaid
   +-----------+
   | Subject   |
   |-----------|
   | notify()  |
   +-----------+
        |
   --------------
   |     |      |
   v     v      v
ObserverA  ObserverB  ObserverC
```

**Trade-offs:**  
- âœ” Decoupled communication  
- âœ” Scales to many listeners  
- âœ˜ Harder to trace flows  
- âœ˜ Risk of cascading updates  

**TA Lens:**  
Useful when evaluating event-driven architectures, pub/sub, or reactive flows.

**Examples:**  
- Pub/Sub systems  
- UI event listeners  

---

## Command

**Intent:** Encapsulate a request as an object.

**Use When:**  
- You want undo/redo  
- You want to queue or log operations  
- You want to parameterise actions  

```mermaid
Invoker ---> Command ---> Receiver
```

**Trade-offs:**  
- âœ” Decouples sender/receiver  
- âœ” Enables undo, logging  
- âœ˜ More classes  
- âœ˜ Can be over-engineered  

**TA Lens:**  
Useful when evaluating workflow engines, job systems, or task queues.

**Examples:**  
- Task runners  
- Workflow steps  

